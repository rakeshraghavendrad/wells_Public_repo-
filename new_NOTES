mapping_dict = {
    "number": "#",
    "unit": "#",
    "apt": "#",
    "apartment": "#",
    "suite": "#",
    "suite #": "#",
    "suite no": "#",
    "apt #": "#",
    "apt no": "#",
    "unit no": "#",
    "unit #": "#",
    "room": "#",
    "rm": "#",
    "floor": "#",
    "flr": "#",
    "building": "#",
    "bldg": "#",
    "lot": "#",
    "block": "#",
    "blk": "#",
    "section": "#",
    "sec": "#",
    "tower": "#",
    "twr": "#",
    "level": "#",
    "ste": "#",  # Common abbreviation for suite
    "app": "#",  # Possible shorthand for apartment
    "no": "#",   # Commonly used as "No 5" for addresses
    "#": "#"     # Ensures existing "#" remains unchanged
}

https://www.apartmentguide.com/blog/how-to-write-an-apartment-address/?utm_source=chatgpt.com

https://www.redfin.com/blog/how-to-write-an-apartment-address/?utm_source=chatgpt.com


from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import textdistance
from fuzzywuzzy import fuzz
import re

# Cosine Similarity with Character N-Grams
def cosine_sim_char(str1, str2):
    vectorizer = TfidfVectorizer(analyzer='char', ngram_range=(2, 4)).fit_transform([str1, str2])
    vectors = vectorizer.toarray()
    return cosine_similarity([vectors[0]], [vectors[1]])[0, 0]

# Levenshtein Similarity
def levenshtein_similarity(str1, str2):
    max_len = max(len(str1), len(str2))
    return 1 - (textdistance.levenshtein.distance(str1, str2) / max_len) if max_len > 0 else 1.0

# FuzzyWuzzy Partial Ratio Similarity
def fuzzy_partial_ratio(str1, str2):
    return fuzz.partial_ratio(str1, str2) / 100  # Normalize between 0-1

# Numeric Similarity Score
def numeric_similarity(address1, address2):
    nums1 = re.findall(r'\d+', address1)  # Extract numbers
    nums2 = re.findall(r'\d+', address2)

    if not nums1 or not nums2:
        return 1.0  # If no numbers, treat as fully similar
    
    nums1 = list(map(int, nums1))
    nums2 = list(map(int, nums2))

    # Compute the average absolute difference
    num_diff = sum(abs(n1 - n2) for n1, n2 in zip(nums1, nums2)) / (len(nums1) + len(nums2))

    # Normalize similarity (lower difference = higher similarity)
    max_value = max(max(nums1, default=1), max(nums2, default=1))
    num_score = 1 - (num_diff / max_value) if max_value > 0 else 1.0

    return max(0, num_score)  # Ensure similarity is in range [0,1]

# Final Address Similarity Score
def address_similarity_score(address1, address2):
    cosine_score = cosine_sim_char(address1, address2)
    levenshtein_score = levenshtein_similarity(address1, address2)
    fuzzy_score = fuzzy_partial_ratio(address1, address2)
    num_score = numeric_similarity(address1, address2)  # New numeric similarity

    # Adjusted Weights (Increase focus on numbers)
    weight_fuzzy = 0.40
    weight_cosine = 0.15
    weight_levenstein = 0.15
    weight_numeric = 0.30  # New weight for numeric similarity

    # Final weighted similarity score
    combined_score = (
        weight_fuzzy * fuzzy_score +
        weight_cosine * cosine_score +
        weight_levenstein * levenshtein_score +
        weight_numeric * num_score
    )

    return combined_score

# Example Test
addr1 = "7744 parkmount dr"
addr2 = "7741 parkmount dr"
similarity = address_similarity_score(addr1, addr2)
print(f"Similarity Score: {similarity:.4f}")

