
# Extract the region of interest (ROI)
xmin, ymin, xmax, ymax = map(int, row[element].split(','))

# Instead of drawing a rectangle, do nothing to retain the background as it is
# If you want to draw a rectangle with the same background color:
background_color = tuple(map(int, cv2.mean(img[ymin:ymax, xmin:xmax])[:3]))

# Drawing a rectangle with the background color to blend it
cv2.rectangle(img, (xmin, ymin), (xmax, ymax), background_color, -1)  # -1 to fill

print(f"Image processed without visible rectangle: {element}")

# Display the updated image
plt.figure(figsize=(10, 20))
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.title(f"Processed Region: {element}")
plt.xticks(fontsize=9)
plt.yticks(fontsize=9)
plt.show()








# Extract the region of interest (ROI)
xmin, ymin, xmax, ymax = map(int, row[element].split(','))
cropped_img = img[ymin:ymax, xmin:xmax]

# Calculate the background color as the average color of the cropped region
# Ensuring that the mean color values are properly cast to integers
mean_color = cv2.mean(cropped_img)[:3]
background_color = (int(mean_color[0]), int(mean_color[1]), int(mean_color[2]))

# Correcting the cv2.rectangle usage
# Use the correct format for the color and set thickness to -1 for filling
cv2.rectangle(img, (xmin, ymin), (xmax, ymax), background_color, -1)

print(f"Image with blurred background on object: {element}")

# Display the updated image
plt.figure(figsize=(10, 20))
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.xticks(fontsize=9)
plt.yticks(fontsize=9)
plt.show()




from PIL import Image, ImageDraw
import os
import matplotlib.pyplot as plt

def rotate_object(df, list_of_angles):
    for index, row in df.iterrows():
        image_path = os.path.join(DIR, row['FILE_NAME'])
        print(f"Processing: {image_path}")

        for element in columns:
            if row[element] is not None:
                # Load the image
                image = Image.open(image_path)
                print(f"Operations performed on: {element}")

                # Extract coordinates
                xmin, ymin, xmax, ymax = map(int, row[element].split(','))
                cropped_img = image.crop((xmin, ymin, xmax, ymax))
                background_color = cropped_img.getpixel((0, 0))

                # Create a blank canvas for rotation
                mod_img = Image.new('RGB', image.size, (255, 255, 255))
                mod_img.paste(image)

                # Rotation Logic
                for angle in list_of_angles:
                    print(f"Rotating by {angle} degrees")

                    # Rotate the cropped image
                    rotated_cropped_img = cropped_img.rotate(angle, expand=True, fillcolor=background_color)

                    # Calculate new position after rotation
                    rotated_width, rotated_height = rotated_cropped_img.size
                    new_x = xmin + (xmax - xmin - rotated_width) // 2
                    new_y = ymin + (ymax - ymin - rotated_height) // 2

                    # Paste the rotated image back to the canvas
                    mod_img.paste(rotated_cropped_img, (new_x, new_y))

                    # Draw the bounding box around the rotated area
                    draw = ImageDraw.Draw(mod_img)
                    draw.rectangle((new_x, new_y, new_x + rotated_width, new_y + rotated_height), outline="red", width=2)

                    # Display the rotated image
                    plt.figure(figsize=(10, 20))
                    plt.imshow(mod_img)
                    plt.title(f"Rotated: {angle}Â°")
                    plt.xticks(fontsize=9)
                    plt.yticks(fontsize=9)
                    plt.show()

# Usage
list_of_angles = [10, 30, 45]
rotate_object(df, list_of_angles)
