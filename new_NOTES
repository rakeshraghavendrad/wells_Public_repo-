import cv2
import numpy as np
import os
from PIL import Image

def apply_blur(df, kernels, kernel_types):
    path = '/path/to/your/images'  # Update this path as needed
    for index, row in df.iterrows():
        image_path = os.path.join(path, row['FILE_NAME'])
        print(f"Processing: {image_path}")
        
        image = cv2.imread(image_path)
        if image is None:
            print(f"Error loading image: {image_path}")
            continue
        
        for element in columns:
            if row[element][0] is not None:
                # Extract coordinates
                xmin, ymin, xmax, ymax = map(int, row[element].split(','))
                print(f"Blurring area: {element} at {xmin, ymin, xmax, ymax}")
                
                # Crop the region of interest (ROI)
                cropped_img = image[ymin:ymax, xmin:xmax]

                for blur_type in kernel_types:
                    for kernel_size in kernels:
                        # Apply different blur techniques
                        if blur_type == "average":
                            blurred = cv2.blur(cropped_img, (kernel_size, kernel_size))
                        elif blur_type == "gaussian":
                            blurred = cv2.GaussianBlur(cropped_img, (kernel_size, kernel_size), 0)
                        elif blur_type == "median":
                            blurred = cv2.medianBlur(cropped_img, kernel_size)
                        else:
                            print(f"Unknown blur type: {blur_type}")
                            continue
                        
                        # Maintain the original background color
                        blurred = cv2.addWeighted(cropped_img, 0.4, blurred, 0.6, 0)
                        
                        # Replace the region with the blurred one
                        image[ymin:ymax, xmin:xmax] = blurred

                        # Save the processed image
                        output_path = os.path.join('/path/to/save', f"blurred_{element}_{blur_type}_{kernel_size}.jpg")
                        cv2.imwrite(output_path, image)
                        print(f"Saved blurred image at: {output_path}")

        # Display the result for verification
        cv2.imshow("Blurred Image", image)
        cv2.waitKey(0)
        cv2.destroyAllWindows()





# Extract the region of interest (ROI)
xmin, ymin, xmax, ymax = map(int, row[element].split(','))

# Instead of drawing a rectangle, do nothing to retain the background as it is
# If you want to draw a rectangle with the same background color:
background_color = tuple(map(int, cv2.mean(img[ymin:ymax, xmin:xmax])[:3]))

# Drawing a rectangle with the background color to blend it
cv2.rectangle(img, (xmin, ymin), (xmax, ymax), background_color, -1)  # -1 to fill

print(f"Image processed without visible rectangle: {element}")

# Display the updated image
plt.figure(figsize=(10, 20))
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.title(f"Processed Region: {element}")
plt.xticks(fontsize=9)
plt.yticks(fontsize=9)
plt.show()








# Extract the region of interest (ROI)
xmin, ymin, xmax, ymax = map(int, row[element].split(','))
cropped_img = img[ymin:ymax, xmin:xmax]

# Calculate the background color as the average color of the cropped region
# Ensuring that the mean color values are properly cast to integers
mean_color = cv2.mean(cropped_img)[:3]
background_color = (int(mean_color[0]), int(mean_color[1]), int(mean_color[2]))

# Correcting the cv2.rectangle usage
# Use the correct format for the color and set thickness to -1 for filling
cv2.rectangle(img, (xmin, ymin), (xmax, ymax), background_color, -1)

print(f"Image with blurred background on object: {element}")

# Display the updated image
plt.figure(figsize=(10, 20))
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.xticks(fontsize=9)
plt.yticks(fontsize=9)
plt.show()




from PIL import Image, ImageDraw
import os
import matplotlib.pyplot as plt

def rotate_object(df, list_of_angles):
    for index, row in df.iterrows():
        image_path = os.path.join(DIR, row['FILE_NAME'])
        print(f"Processing: {image_path}")

        for element in columns:
            if row[element] is not None:
                # Load the image
                image = Image.open(image_path)
                print(f"Operations performed on: {element}")

                # Extract coordinates
                xmin, ymin, xmax, ymax = map(int, row[element].split(','))
                cropped_img = image.crop((xmin, ymin, xmax, ymax))
                background_color = cropped_img.getpixel((0, 0))

                # Create a blank canvas for rotation
                mod_img = Image.new('RGB', image.size, (255, 255, 255))
                mod_img.paste(image)

                # Rotation Logic
                for angle in list_of_angles:
                    print(f"Rotating by {angle} degrees")

                    # Rotate the cropped image
                    rotated_cropped_img = cropped_img.rotate(angle, expand=True, fillcolor=background_color)

                    # Calculate new position after rotation
                    rotated_width, rotated_height = rotated_cropped_img.size
                    new_x = xmin + (xmax - xmin - rotated_width) // 2
                    new_y = ymin + (ymax - ymin - rotated_height) // 2

                    # Paste the rotated image back to the canvas
                    mod_img.paste(rotated_cropped_img, (new_x, new_y))

                    # Draw the bounding box around the rotated area
                    draw = ImageDraw.Draw(mod_img)
                    draw.rectangle((new_x, new_y, new_x + rotated_width, new_y + rotated_height), outline="red", width=2)

                    # Display the rotated image
                    plt.figure(figsize=(10, 20))
                    plt.imshow(mod_img)
                    plt.title(f"Rotated: {angle}Â°")
                    plt.xticks(fontsize=9)
                    plt.yticks(fontsize=9)
                    plt.show()

# Usage
list_of_angles = [10, 30, 45]
rotate_object(df, list_of_angles)
