mapping_dict = {
    "number": "#",
    "unit": "#",
    "apt": "#",
    "apartment": "#",
    "suite": "#",
    "suite #": "#",
    "suite no": "#",
    "apt #": "#",
    "apt no": "#",
    "unit no": "#",
    "unit #": "#",
    "room": "#",
    "rm": "#",
    "floor": "#",
    "flr": "#",
    "building": "#",
    "bldg": "#",
    "lot": "#",
    "block": "#",
    "blk": "#",
    "section": "#",
    "sec": "#",
    "tower": "#",
    "twr": "#",
    "level": "#",
    "ste": "#",  # Common abbreviation for suite
    "app": "#",  # Possible shorthand for apartment
    "no": "#",   # Commonly used as "No 5" for addresses
    "#": "#"     # Ensures existing "#" remains unchanged
}

https://www.apartmentguide.com/blog/how-to-write-an-apartment-address/?utm_source=chatgpt.com

https://www.redfin.com/blog/how-to-write-an-apartment-address/?utm_source=chatgpt.com


from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import textdistance
from fuzzywuzzy import fuzz

# 1. Cosine Similarity with Character N-Grams (More robust to missing spaces)
def cosine_sim_char(str1, str2):
    vectorizer = TfidfVectorizer(analyzer='char', ngram_range=(2, 4)).fit_transform([str1, str2])
    vectors = vectorizer.toarray()
    return cosine_similarity([vectors[0]], [vectors[1]])[0, 0]

# 2. Levenshtein Similarity (Works at character level)
def levenshtein_similarity(str1, str2):
    max_len = max(len(str1), len(str2))
    return 1 - (textdistance.levenshtein.distance(str1, str2) / max_len) if max_len > 0 else 1.0

# 3. FuzzyWuzzy Partial Ratio Similarity (Handles missing spaces well)
def fuzzy_partial_ratio(str1, str2):
    return fuzz.partial_ratio(str1, str2) / 100  # Normalize between 0-1

# 4. Jaro-Winkler Similarity (Handles both numbers & characters well)
def jaro_winkler_sim(str1, str2):
    return textdistance.jaro_winkler(str1, str2)

# Function to calculate final similarity score (with optimized weights)
def address_similarity_score(address1, address2):
    cosine_score = cosine_sim_char(address1, address2)
    levenshtein_score = levenshtein_similarity(address1, address2)
    fuzzy_score = fuzzy_partial_ratio(address1, address2)
    jaro_winkler_score = jaro_winkler_sim(address1, address2)  # New Jaro-Winkler similarity

    # Adjusted Weights (More emphasis on Jaro-Winkler for better address handling)
    weight_fuzzy = 0.30
    weight_cosine = 0.15
    weight_levenstein = 0.15
    weight_jaro_winkler = 0.40  # Giving higher weight to Jaro-Winkler

    # Final weighted similarity score
    combined_score = (
        weight_fuzzy * fuzzy_score +
        weight_cosine * cosine_score +
        weight_levenstein * levenshtein_score +
        weight_jaro_winkler * jaro_winkler_score
    )

    return combined_score

# Example Test Cases
addr1 = "7744 parkmount dr"
addr2 = "7741 parkmount dr"

similarity = address_similarity_score(addr1, addr2)
print(f"Similarity Score: {similarity:.4f}")  # Expected ~0.94-0.96

print(f"Similarity Score: {similarity:.4f}")

