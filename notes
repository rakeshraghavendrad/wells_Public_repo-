def generate_summary(row):
    # Convert values to float
    similarity_scores = row[['jaro_winkler', 'fuzzy_partial_ratio', 'levenshtein_score']].astype(float)

    # Check if all scores are equal
    if similarity_scores.nunique() == 1:
        return f"All similarity scores are equal ({similarity_scores.iloc[0]}). No significant mismatch detected."

    # Find the minimum score(s)
    min_score = similarity_scores.min()
    min_score_metrics = similarity_scores[similarity_scores == min_score].index.tolist()  # List of lowest score metrics

    # Handle cases where two similarity scores are tied for lowest
    if len(min_score_metrics) == 2:
        pair = set(min_score_metrics)  # Convert to set for easy comparison
        if pair == {"levenshtein_score", "fuzzy_partial_ratio"}:
            message = "Character-level and partial-word differences detected, possibly typos or slight modifications."
        elif pair == {"levenshtein_score", "jaro_winkler"}:
            message = "Character-level differences and ordering mismatch detected."
        elif pair == {"fuzzy_partial_ratio", "jaro_winkler"}:
            message = "Missing or additional words detected, but structure remains similar."
    elif len(min_score_metrics) == 1:
        # Only one lowest similarity metric
        min_score_metric = min_score_metrics[0]
        if min_score_metric == "levenshtein_score":
            message = "Character-level differences detected, possibly typos or missing spaces."
        elif min_score_metric == "jaro_winkler":
            message = "Prefix mismatch or different order detected."
        elif min_score_metric == "fuzzy_partial_ratio":
            message = "Additional/missing words may be present in one of the addresses."

    return f"{message} (Weakest scores: {', '.join(min_score_metrics)}={round(min_score, 2)})"

# Apply function to generate summary
df_1['Summary'] = df_1.apply(generate_summary, axis=1)
